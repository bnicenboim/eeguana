% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr_verbs.R
\name{dplyr_verbs}
\alias{dplyr_verbs}
\alias{eeg_mutate}
\alias{eeg_transmute}
\alias{eeg_filter}
\alias{eeg_summarize}
\alias{eeg_group_by}
\alias{eeg_ungroup}
\alias{eeg_select}
\alias{eeg_rename}
\alias{eeg_rename_with}
\alias{eeg_groups}
\alias{eeg_groups.eeg_lst}
\alias{eeg_group_vars}
\alias{eeg_anti_join}
\alias{eeg_left_join}
\alias{eeg_semi_join}
\alias{eeg_vars}
\alias{eeg_pull}
\title{Dplyr-like functions for manipulating eeg_lst objects.}
\usage{
eeg_mutate(.data, ...)

eeg_transmute(.data, ...)

eeg_filter(.data, ..., .preserve = FALSE)

eeg_summarize(.data, ..., .groups = "keep")

eeg_group_by(.data, ..., .add = FALSE, .drop = FALSE)

eeg_ungroup(.data, ...)

eeg_select(.data, ...)

eeg_rename(.data, ...)

eeg_rename_with(.data, .fn, .cols = where(is_channel_dbl), ...)

eeg_groups(x)

\method{eeg_groups}{eeg_lst}(x)

eeg_group_vars(x)

eeg_anti_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

eeg_left_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

eeg_semi_join(x, y, by = NULL, suffix = c(".x", ".y"), ...)

eeg_vars(x)

eeg_pull(.data, var = -1, name = NULL, ...)
}
\arguments{
\item{.data}{An eeg_lst.}

\item{...}{Name-value pairs of expressions; see \link[dplyr:dplyr-package]{dplyr} for more help.}

\item{.preserve}{Not in use, for compatibility reasons.}

\item{.groups}{Only .groups = "keep" is available.  Same grouping structure as .data.}

\item{.add}{When FALSE, the default, group_by() will override existing groups. To add to the existing groups, use .add = TRUE.}

\item{.drop}{Only .drop = FALSE is available, empty groups are never dropped.}

\item{x}{An eeg_lst.}

\item{y}{A data frame, tibble, or data.table.}

\item{by}{A character vector of variables to join by.

If \code{NULL}, the default, \verb{*_join()} will perform a natural join, using all
variables in common across \code{x} and \code{y}. A message lists the variables so that you
can check they're correct; suppress the message by supplying \code{by} explicitly.

To join by different variables on \code{x} and \code{y}, use a named vector.
For example, \code{by = c("a" = "b")} will match \code{x$a} to \code{y$b}.

To join by multiple variables, use a vector with length > 1.
For example, \code{by = c("a", "b")} will match \code{x$a} to \code{y$a} and \code{x$b} to
\code{y$b}. Use a named vector to match different variables in \code{x} and \code{y}.
For example, \code{by = c("a" = "b", "c" = "d")} will match \code{x$a} to \code{y$b} and
\code{x$c} to \code{y$d}.

To perform a cross-join, generating all combinations of \code{x} and \code{y},
use \code{by = character()}.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into the
same src as \code{x}.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}

\item{var}{A variable specified as:
\itemize{
\item a literal variable name
\item a positive integer, giving the position counting from the left
\item a negative integer, giving the position counting from the right.
}

The default returns the last column (on the assumption that's the
column you've created most recently).

This argument is taken by expression and supports
\link[rlang:nse-force]{quasiquotation} (you can unquote column
names and column locations).}

\item{name}{An optional parameter that specifies the column to be used
as names for a named vector. Specified in a similar manner as \code{var}.}

\item{.by_reference}{Acts in place rewriting the eeg_lst object.}
}
\value{
An eeg_lst object.
}
\description{
Manipulate the signal table and the segments table of an eeg_lst.
}
\details{
Wrappers for \code{\link[dplyr:dplyr-package]{dplyr}}'s commands that act on different parts
\code{eeg_lst} objects. Functions that drop or rename columns won't remove columns starting with a dot. These functions are powered by \code{\link[data.table:data.table]{data.table}}, and inspired by the way \code{\link[tidytable:tidytable]{tidytable}} works.

The following wrappers act in a special way for \code{eeg_lst} objects:
\itemize{
\item \verb{*_join()}: joins an external table to the \emph{segments} table of the eeg_lst.
\item \code{eeg_mutate()} and \code{eeg_transmute()}: mutates the signal_tbl table when is applied to a channel (or a column of the signal table), and mutates the segments table otherwise. It can also mutates by reference.
\item \code{summarize()} summarizes the channel of the signal_tbl table.
\item \code{pull()} only pulls columns of the signal table
}

In addition, \verb{_at()}, and \verb{_if()} versions of the functions should work as well. Notice that  the \verb{_at()} versions are
much faster than the \verb{_if()} versions of these commands.
\subsection{Gotchas}{

These functions emulate \link{dplyr} functionality but they are actually powered by \link{data.table}, and some times they might be behave a bit differently than the dplyr counterpart.
\itemize{
\item The default values of the arguments might be different, and some arguments might not exist for the eeguana dplyr-like functions.
\item grouped mutations behave slightly different than ungrouped ones: Channel properties are removed if the data is ungrouped and one does \code{mutate(data, channel = 0)}, but not if the data is grouped.
\item eeguana's \link{mutate} doesn't allow to refer back to a recently created channel: \code{data_eeg \%>\% mutate(X = F1 *2, Y = X)} is not valid. One needs to do \code{data_eeg \%>\% mutate(X = F1) \%>\% mutate(Y = X)}.
\item eeguana's \link{mutate} doesn't use the most updated value of a column from the same call. If X is a channel, then \code{data_eeg \%>\% mutate(X = X *2, Y = X+1)} will add \code{1} to the original value of \code{X}, and not to the latest one.
\item \code{n()} doesn't work, instead \code{length(.sample)} will give the same answer.
\item \code{across()} and \code{where()} cannot be used.
\item \link{eeg_filter} behaves similarly to dplyr's \code{\link[dplyr:filter]{filter}}. If you want to filter the signal using IIR or FIR filters use \link[=filt]{eeg_filt*} functions.
}
}

\subsection{Pitfalls}{

These functions not only edit the eeg_lst objects but they also do book-keeping: They remove unnecessary channels, or update their information and they ensure that three tables (signal, segments, and events) match. It's then not recommended to edit the signal and segments table directly. (The events and channels table can be edited directly by doing \code{events_tbl(data_eeg) <- ...} or \code{channels_tbl(data_eeg) <- ...}).
}
}
\examples{
library(dplyr)
# Create new channel in the signal table
data_faces_ERPs \%>\%
  mutate(tmp = Fz - Cz)

# Create a new condition in the segments table
data_faces_ERPs \%>\%
  mutate(code = ifelse(condition == "faces", 1, -1))

# Create a new channel and drop all others
data_faces_ERPs \%>\%
  transmute(Occipital = chs_mean(O1, O2, Oz,
    na.rm = TRUE
  ))

# Extract data associated with a condition
data_faces_ERPs \%>\%
  filter(condition == "faces")

# Group and summarize
data_faces_ERPs \%>\%
  # Convert samples to times, filter between timepoints
  filter(between(
    as_time(.sample, .unit = "ms"),
    100, 200
  )) \%>\%
  # Find mean amplitude of Fz for each condition
  group_by(condition) \%>\%
  summarize(mean.amplitude = mean(Fz))

# Select specific electrodes
data_faces_ERPs \%>\%
  select(O1, O2, P7, P8)

# Rename a variable
data_faces_ERPs \%>\%
  rename(Predictor = condition)
}
\seealso{
Other tidyverse-like functions: 
\code{\link{bind}()},
\code{\link{drop_incomplete_segments}()},
\code{\link{slice_signal}()}
}
\concept{tidyverse-like functions}
