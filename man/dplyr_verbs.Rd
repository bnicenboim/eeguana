% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr_verbs.R
\name{dplyr_verbs}
\alias{dplyr_verbs}
\alias{mutate.eeg_lst}
\alias{transmute.eeg_lst}
\alias{filter.eeg_lst}
\alias{filter.eeg_ica_lst}
\alias{summarise.eeg_lst}
\alias{group_by.eeg_lst}
\alias{ungroup.eeg_lst}
\alias{select.eeg_lst}
\alias{rename.eeg_lst}
\alias{groups.eeg_lst}
\alias{group_vars.eeg_lst}
\alias{anti_join.eeg_lst}
\alias{left_join.eeg_lst}
\alias{semi_join.eeg_lst}
\alias{tbl_vars.eeg_lst}
\title{Dplyr verbs overloaded for manipulating eeg_lst objects.}
\usage{
\method{mutate}{eeg_lst}(.data, ...)

\method{transmute}{eeg_lst}(.data, ...)

filter.eeg_lst(.data, ..., .preserve = FALSE)

filter.eeg_ica_lst(.data, ..., .preserve = FALSE)

\method{summarise}{eeg_lst}(.data, ...)

\method{group_by}{eeg_lst}(.data, ..., add = FALSE, .drop = FALSE)

\method{ungroup}{eeg_lst}(.data, ...)

\method{select}{eeg_lst}(.data, ...)

\method{rename}{eeg_lst}(.data, ...)

\method{groups}{eeg_lst}(x)

\method{group_vars}{eeg_lst}(x)

\method{anti_join}{eeg_lst}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), ...)

\method{left_join}{eeg_lst}(x, y, by = NULL, copy = FALSE,
  suffix = c(".x", ".y"), ...)

\method{semi_join}{eeg_lst}(x, y, by = NULL, suffix = c(".x", ".y"),
  ...)

tbl_vars.eeg_lst(x)
}
\arguments{
\item{.data}{An eeg_lst.}

\item{...}{Name-value pairs of expressions; see \link[dplyr:dplyr]{dplyr} for more help.}

\item{.preserve}{Not in use, for compatibility reasons.}

\item{add}{Not in use, for compatibility reasons.}

\item{.drop}{When .drop = TRUE, empty groups are dropped. (FALSE by default.)}

\item{x}{An eeg_lst.}

\item{y}{A data frame, tibble, or data.table.}

\item{by}{a character vector of variables to join by.  If \code{NULL}, the
default, \code{*_join()} will do a natural join, using all variables with
common names across the two tables. A message lists the variables so
that you can check they're right (to suppress the message, simply
explicitly list the variables that you want to join).

To join by different variables on x and y use a named vector.
For example, \code{by = c("a" = "b")} will match \code{x.a} to
\code{y.b}.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into the
same src as \code{x}.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}
}
\value{
An eeg_lst object.
}
\description{
Manipulate the signal table and the segments table of an eeg_lst.
}
\details{
Wrappers for \code{\link[dplyr:dplyr]{dplyr}}'s commands that act on different parts
\code{eeg_lst} objects. Functions that drop or rename column won't remove columns starting with a dot.
The following wrappers act in a special way for \code{eeg_lst} objects:
\itemize{
\item \code{*_join()}: joins an external table to the \emph{segments} table of the eeg_lst.
\item \code{mutate()} and \code{transmute()} Variables that are a function of a channel are added to the signal_tbl table, and other variables are added to the segments table.
\item \code{summarize()} summarizes the channel of the signal_tbl table.
}

In addition, \code{_at()}, and \code{_if()} versions of the functions should work as well. Notice that  the \code{_at()} versions are
much faster than the \code{_if()} versions of these commands.
}
\examples{
library(dplyr)
# Create new channel in the signal table
data_faces_ERPs \%>\%
  mutate(tmp = Fz - Cz)

# Create a new condition in the segments table
data_faces_ERPs \%>\%
  mutate(code = ifelse(condition == "faces", 1, -1))

# Create a new channel and drop all others
data_faces_ERPs \%>\%
  transmute(Occipital = chs_mean(O1, O2, Oz,
    na.rm = TRUE
  ))

# Extract data associated with a condition
data_faces_ERPs \%>\%
  filter(condition == "faces")

# Group and summarize
data_faces_ERPs \%>\%
  # Convert samples to times, filter between timepoints
  filter(between(
    as_time(.sample, unit = "ms"),
    100, 200
  )) \%>\%
  # Find mean amplitude of Fz for each condition
  group_by(condition) \%>\%
  summarize(mean.amplitude = mean(Fz))

# Select specific electrodes
data_faces_ERPs \%>\%
  select(O1, O2, P7, P8)

# Rename a variable
data_faces_ERPs \%>\%
  rename(Predictor = condition)
}
\concept{dplyr functions}
