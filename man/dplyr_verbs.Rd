% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr_verbs.R
\name{dplyr_verbs}
\alias{dplyr_verbs}
\alias{eeg_mutate}
\alias{eeg_transmute}
\alias{eeg_filter}
\alias{eeg_summarize}
\alias{eeg_summarise}
\alias{eeg_group_by}
\alias{eeg_ungroup}
\alias{eeg_select}
\alias{eeg_rename}
\alias{eeg_rename_with}
\alias{eeg_groups}
\alias{eeg_groups.eeg_lst}
\alias{eeg_group_vars}
\alias{eeg_anti_join}
\alias{eeg_left_join}
\alias{eeg_semi_join}
\alias{eeg_pull}
\alias{across}
\alias{across_ch}
\alias{c_across_ch}
\alias{c_across}
\title{Dplyr-like functions for manipulating eeg_lst objects.}
\usage{
eeg_mutate(.data, ...)

eeg_transmute(.data, ...)

eeg_filter(.data, ..., .preserve = FALSE)

eeg_summarize(.data, ..., .groups = "keep")

eeg_summarise(.data, ..., .groups = "keep")

eeg_group_by(.data, ..., .add = FALSE, .drop = FALSE)

eeg_ungroup(.data, ...)

eeg_select(.data, ...)

eeg_rename(.data, ...)

eeg_rename_with(.data, .fn, .cols = where(is_channel_dbl), ...)

eeg_groups(x)

\method{eeg_groups}{eeg_lst}(x)

eeg_group_vars(x)

eeg_anti_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

eeg_left_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)

eeg_semi_join(x, y, by = NULL, suffix = c(".x", ".y"), ...)

eeg_pull(.data, var = -1, name = NULL, ...)

across(.cols = everything(), .fns = NULL, ..., .names = NULL)

across_ch(.fns = NULL, ..., .names = NULL)

c_across_ch()

c_across(.cols = everything())
}
\arguments{
\item{.data}{An eeg_lst.}

\item{...}{Name-value pairs of expressions; see \link[dplyr:dplyr-package]{dplyr} for more help.}

\item{.preserve}{Not in use, for compatibility reasons.}

\item{.groups}{Only .groups = "keep" is available.  Same grouping structure as .data.}

\item{.add}{When FALSE, the default, group_by() will override existing groups. To add to the existing groups, use .add = TRUE.}

\item{.drop}{Only .drop = FALSE is available, empty groups are never dropped.}

\item{.fn}{Function to transform the names with.}

\item{.cols}{Columns to rename. Defaults to all columns. \code{tidyselect} compatible.}

\item{x}{An eeg_lst.}

\item{y}{A data frame, tibble, or data.table.}

\item{by}{A join specification created with \code{\link[dplyr:join_by]{join_by()}}, or a character
vector of variables to join by.

If \code{NULL}, the default, \verb{*_join()} will perform a natural join, using all
variables in common across \code{x} and \code{y}. A message lists the variables so
that you can check they're correct; suppress the message by supplying \code{by}
explicitly.

To join on different variables between \code{x} and \code{y}, use a \code{\link[dplyr:join_by]{join_by()}}
specification. For example, \code{join_by(a == b)} will match \code{x$a} to \code{y$b}.

To join by multiple variables, use a \code{\link[dplyr:join_by]{join_by()}} specification with
multiple expressions. For example, \code{join_by(a == b, c == d)} will match
\code{x$a} to \code{y$b} and \code{x$c} to \code{y$d}. If the column names are the same between
\code{x} and \code{y}, you can shorten this by listing only the variable names, like
\code{join_by(a, c)}.

\code{\link[dplyr:join_by]{join_by()}} can also be used to perform inequality, rolling, and overlap
joins. See the documentation at \link[dplyr:join_by]{?join_by} for details on
these types of joins.

For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, \code{by = c("a", "b")} joins \code{x$a}
to \code{y$a} and \code{x$b} to \code{y$b}. If variable names differ between \code{x} and \code{y},
use a named character vector like \code{by = c("x_a" = "y_a", "x_b" = "y_b")}.

To perform a cross-join, generating all combinations of \code{x} and \code{y}, see
\code{\link[dplyr:cross_join]{cross_join()}}.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into the
same src as \code{x}.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}

\item{var}{A variable specified as:
\itemize{
\item a literal variable name
\item a positive integer, giving the position counting from the left
\item a negative integer, giving the position counting from the right.
}

The default returns the last column (on the assumption that's the
column you've created most recently).

This argument is taken by expression and supports
\link[rlang:topic-inject]{quasiquotation} (you can unquote column
names and column locations).}

\item{name}{An optional parameter that specifies the column to be used
as names for a named vector. Specified in a similar manner as \code{var}.}

\item{.fns}{Function to apply. Can be a purrr-style lambda.
Can pass also list of functions.}

\item{.names}{A glue specification that helps with renaming output columns.
\code{{.col}} stands for the selected column, and \code{{.fn}} stands for the name of the function being applied.
The default (\code{NULL}) is equivalent to \code{"{.col}"} for a single function case and \code{"{.col}_{.fn}"}
when a list is used for \code{.fns}.}
}
\value{
An eeg_lst object.
}
\description{
Manipulate the signal table and the segments table of an eeg_lst with dplyr-like functions.
}
\details{
Wrappers for \code{\link[dplyr:dplyr-package]{dplyr}}'s commands that act
\code{eeg_lst} objects. Functions that drop or rename columns won't remove columns starting with a dot. These functions are powered by \code{\link[data.table:data.table]{data.table}} through \code{\link[tidytable:tidytable]{tidytable}}.

The following wrappers act in a special way for \code{eeg_lst} objects:
\itemize{
\item \verb{eeg_*_join()}: joins an external table to the \emph{segments} table of the eeg_lst.
\item \code{eeg_mutate()} and \code{eeg_transmute()}: mutates the signal_tbl table when is applied to a channel (or a column of the signal table), and mutates the segments table otherwise. It can also mutates by reference.
\item \code{eeg_summarize()} summarizes the channel of the signal_tbl table.
\item \code{eeg_pull()} only pulls columns of the signal table
}

In addition, \code{across()}, and \code{c_across()} work as well. Notice that  there are convienent wrappers \code{across_ch()} and \code{c_across_ch()} where the argument \code{.cols} is always set to \code{where(is_channel_dbl)}.
\subsection{Gotchas}{

These functions emulate \link{dplyr} functionality but they are actually powered by the wrapper of \link{data.table},  \link{tidytable} and some times they might be behave a bit differently than the dplyr counterpart.
\itemize{
\item The default values of the arguments might be different, and some arguments might not exist for the eeguana dplyr-like functions.
\item Grouped mutations behave slightly different than ungrouped ones: Channel properties are removed if the data is ungrouped and one does \code{eeg_mutate(data, channel = 0)}, but not if the data is grouped.
\item eeguana's \link{eeg_mutate} doesn't allow to refer back to a recently created channel: \code{data_eeg \%>\% eeg_mutate(X = F1 *2, Y = X)} is not valid. One needs to do \code{data_eeg \%>\% eeg_mutate(X = F1) \%>\% eeg_mutate(Y = X)}.
\item eeguana's \link{eeg_mutate} doesn't use the most updated value of a column from the same call. If X is a channel, then \code{data_eeg \%>\% eeg_mutate(X = X *2, Y = X+1)} will add \code{1} to the original value of \code{X}, and not to the latest one.
\item \link{eeg_filter} behaves similarly to dplyr's \code{\link[dplyr:filter]{filter}}. If you want to filter the signal using IIR or FIR filters use \link[=filt]{eeg_filt*} functions.
}
}

\subsection{Pitfalls}{

These functions not only edit the eeg_lst objects but they also do book-keeping: They remove unnecessary channels, or update their information and they ensure that three tables (signal, segments, and events) match. It's then not recommended to edit the signal and segments table directly. (The events and channels table can be edited directly by doing \code{events_tbl(data_eeg) <- ...} or \code{channels_tbl(data_eeg) <- ...}).
}
}
\examples{
library(dplyr)
# Create new channel in the signal table
data_faces_ERPs \%>\%
  eeg_mutate(tmp = Fz - Cz)

# Create a new condition in the segments table
data_faces_ERPs \%>\%
  eeg_mutate(code = ifelse(condition == "faces", 1, -1))

# Create a new channel and drop all others
data_faces_ERPs \%>\%
  eeg_transmute(Occipital = chs_mean(O1, O2, Oz,
    na.rm = TRUE
  ))

# Extract data associated with a condition
data_faces_ERPs \%>\%
  eeg_filter(condition == "faces")

# Group and summarize
data_faces_ERPs \%>\%
  # Convert samples to times, filter between timepoints
  eeg_filter(between(
    as_time(.sample, .unit = "ms"),
    100, 200
  )) \%>\%
  # Find mean amplitude of Fz for each condition
  eeg_group_by(condition) \%>\%
  eeg_summarize(mean.amplitude = mean(Fz))

# Mean of each channel
data_faces_ERPs \%>\%
  eeg_summarize(across_ch(mean))

# Select specific electrodes
data_faces_ERPs \%>\%
  eeg_select(O1, O2, P7, P8)

# Rename a variable
data_faces_ERPs \%>\%
  eeg_rename(Predictor = condition)
}
\seealso{
Other tidyverse-like functions: 
\code{\link{drop_incomplete_segments}()},
\code{\link{eeg_bind}()},
\code{\link{eeg_slice_signal}()}
}
\concept{tidyverse-like functions}
